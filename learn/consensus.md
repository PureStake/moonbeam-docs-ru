---
title: Консенсусы Парачейна 
description: Узнайте обо всех составляющих фреймворка консенсуса Nimbus от Moonbeam и о том, как он работает в рамках модели общей безопасности Polkadot
---

# Парачейн фреймворк консенсуса Nimbus 

![Moonbeam Consensus Banner](/images/consensus/consensus-banner.png)

## Введение {: #introduction } 

Polkadot основывается на [гибридной модели консенсуса](https://wiki.polkadot.network/docs/learn-consensus). В такой схеме механизм завершения блока и механизм производства блоков разделены. Следовательно, парачайны должны заботиться только о производстве блоков и полагаться на relay chain для подтверждения переходов состояния.

На уровне парачейна производители блоков называются [коллаторы](https://wiki.polkadot.network/docs/learn-collator). Они поддерживают парачейны (такие как Moonbeam), получая транзакции от пользователей и передавая блоки relay chain [validators](https://wiki.polkadot.network/docs/learn-validator).

Однако парачейны могут столкнуться со следующими проблемами, которые им необходимо решить в условиях отсутствия доверия и децентрализации (если это применимо):

 - Каким нодам  в сети разрешено быть авторами блоков?
 - Если разрешено несколько нод, будут ли они иметь право на участие одновременно? Только одна? Может быть, несколько?

Предлагаем вашему вниманию Nimbus. Nimbus - это фреймворк для построения алгоритмов консенсуса на основе слотов на [Cumulus](https://github.com/paritytech/cumulus)-базированных парачейнах. Он стремится предоставить стандартные реализации для логистических частей таких механизмов консенсуса и полезные характеристики для реализации элементов (фильтров), которые исследователи и разработчики хотят настроить. Эти фильтры можно настраивать, чтобы определить, что такое слот авторства блока и что из них можно составить, так что авторство блока ограничивается подмножеством коллаторов на нескольких этапах.

Например, Moonbeam использует двухуровневый подход. Первый уровень включает в себя фильтр parachain staking, который помогает выбрать активный пул коллаторов среди всех кандидатов на роль коллатора, используя ранжирование на основе staked. Второй уровень добавляет еще один фильтр, который сужает число коллаторов до подмножества для каждого слота.

Обратите внимание, что Nimbus может только ответить, какой коллатор(ов) имеет право произвести блок парачейна в следующем доступном слоте. Именно механизм консенсуса [Cumulus](https://wiki.polkadot.network/docs/build-cumulus#docsNav) отмечает этот парачейн-блок как лучший, а в конечном итоге гибридная модель консенсуса [BABE](https://wiki.polkadot.network/docs/learn-consensus#babe) и [GRANDPA](https://wiki.polkadot.network/docs/learn-consensus#grandpa-finality-gadget) (relay chain) включает этот парачейн-блок в relay chain и завершает его. Как только все форки relay chain будут разрешены на уровне relay chain, этот парачейн блок будет окончательно сформирован


В следующих двух разделах рассматривается стратегия фильтрации, используемая в настоящее время в Moonbeam.

## Фильтрация парачейн стейкинга  {: #parachain-staking-filtering }  

Коллаторы могут присоединиться к пулу кандидатов, просто связав некоторое количество токенов через extrinsic. Попав в пул, держатели токенов могут увеличить долю коллатора через номинацию (также называемую стейкингом), то есть на уровне парачейна.

Парачейн стейкинг - это первый из двух фильтров Nimbus, применяемых к пулу кандидатов в коллаторы. Он выбирает лучших {{ networks.moonbase.staking.max_collators }} коллаторов с точки зрения количества токенов, размещенных в сети, что включает в себя фонд коллаторов и номинации от держателей токенов. Этот отфильтрованный пул называется отобранными кандидатами, и отобранные кандидаты обновляются каждый раунд (который длится {{ networks.moonbase.staking.round_blocks }} блоков). Для данного раунда следующая диаграмма описывает фильтрацию парачейн стейкинга:

![Nimbus Parachain Staking Filter](/images/consensus/consensus-images1.png)

Из этого пула применяется другой фильтр, чтобы отобрать подмножество подходящих коллаторов для следующего слота авторства блока.

Если вы хотите узнать больше о стейкинге, посетите наш раздел с документацией по [стейкингу](/staking/overview/).

## Фильтрация подмножеств фиксированного размера {: #fixed-size-subset-filtering } 

После применения фильтра парачейн-стейкинга и получения отобранных кандидатов применяется второй фильтр на основе блока за блоком, который помогает сузить круг отобранных кандидатов до меньшего числа подходящих коллаторов для следующего слота автора блока.

В общих чертах, этот второй фильтр выбирает псевдослучайное подмножество ранее отобранных кандидатов. Коэффициент приемлемости, настраиваемый параметр, определяет размер этого подмножества.

Высокий коэффициент соответствия приводит к тому, что сеть имеет меньше шансов пропустить слот для производства блока, так как большее количество коллаторов будет иметь право предложить блок для определенного слота. Однако только определенное количество валидаторов назначается на парачейн , что означает, что большинство этих блоков не будут поддержаны валидатором. Для тех блоков, которые поддерживаются, большее число валидаторов означает, что цепочке передачи данных может потребоваться больше времени, чтобы решить все возможные проблемы и вернуть окончательно сформированный блок. Более того, это может создать несправедливое преимущество для определенных валидаторов, которые смогут быстрее доставить предложенный ими блок валидаторам relay chain, обеспечив себе большую часть вознаграждения за блок (если таковое имеется).

С другой стороны, более низкий коэффициент приемлемости может обеспечить более быстрое время завершения блока и более справедливое распределение производства блоков между коллаторами. Однако, если коллаторы, имеющие право на участие, не смогут предложить блок (по какой-либо причине), сеть пропустит блок, что повлияет на ее стабильность.

После определения размера подмножества коллаторы выбираются случайным образом с использованием источника энтропии. В настоящее время реализован внутренний алгоритм подбрасывания монет, но позже он будет перенесен на использование [маяка случайности] relay chain (https://wiki.polkadot.network/docs/learn-randomness). Следовательно, для каждого блока relay chain выбирается новое подмножество подходящих коллаторов. Для данного раунда и данного блока `XYZ` следующая диаграмма описывает фильтрацию подмножества фиксированного размера: 

![Nimbus Parachain Staking Filter](/images/consensus/consensus-images2.png)

## Почему Nimbus? {: #why-nimbus? } 

Вы можете спросить себя: но почему именно Nimbus? Изначально, когда разрабатывался Moonbeam, он не был предусмотрен. По мере развития Moonbeam необходимость в более настраиваемом, но простом механизме консенсуса парачейна стала очевидной, поскольку имеющиеся методы обладали некоторыми недостатками или техническими ограничениями. 

<!-- При консенсусе [relay chain provided consensus](https://github.com/paritytech/cumulus/blob/master/client/consensus/relay-chain/src/lib.rs) каждый узел рассматривает себя в качестве колатора и может предложить блок-кандидат  парачейну. Затем relay chain должна решить все возможные варианты форков и окончательно утвердить блок. 

Механизм консенсуса [AuRa](https://crates.io/crates/sc-consensus-aura) (сокращение от authority-round) основан на известном списке авторитетов, которые по очереди предлагают блоки в каждом слоте. Каждый авторитет может предложить только один блок в слот и строится поверх самой длинной цепочки.-->

С Nimbus написать механизм консенсуса парачейна так же просто, как написать набор модулей! Эта простота и гибкость - главная ценность, которую он добавляет.

Некоторые технические преимущества Nimbus рассматриваются в следующих разделах.

### Вес и дополнительное исполнение {: #weight-and-extra-execution } 

Nimbus помещает выполнение проверки автора в [набор модулей Substrate](https://substrate.dev/docs/knowledgebase/runtime/pallets). На первый взгляд, можно подумать, что это увеличивает нагрузку на выполнение одного блока по сравнению с проверкой вне цепи. Но подумайте об этом с точки зрения валидатора.

Валидаторы также должны будут проверять автора. Если поместить логику выполнения проверки автора в набор модулей, время выполнения можно сопоставить с эталоном и оценить с помощью взвешивания. Если это время выполнения не будет учтено, существует риск того, что блок превысит лимит выполнения WASM relay chain (в настоящее время 0,5 секунды).

На практике эта проверка будет быстрой и, скорее всего, не приведет к превышению лимита времени выполнения. Но с теоретической точки зрения учет ее веса лучше для целей реализации.

### Возможность повторного использования {: #reusability } 

Еще одним преимуществом переноса выполнения проверки автора в набор модулей, а не в пользовательский исполнитель, является то, что один единственный исполнитель может быть повторно использован для любого консенсуса, который может быть выражен в рамках Nimbus. Это алгоритмы, основанные на слотах и заверенные подписью.

Например, [relay-chain provided consensus](https://github.com/paritytech/cumulus/blob/master/client/consensus/relay-chain/src/lib.rs), [AuRa](https://crates.io/crates/sc-consensus-aura) и [BABE](https://crates.io/crates/sc-consensus-babe) имеют каждый свой собственный пользовательский исполнитель. С Nimbus эти механизмы консенсуса могут повторно использовать один и тот же исполнитель. О силе возможности повторного использования свидетельствует реализация AuRa в Nimbus менее чем в 100 строках кода.

### Консенсус горячей замены {: #hotswapping-consensus } 

Команды, создающие парачейны, могут время от времени менять, настраивать или корректировать алгоритм консенсуса. Без Nimbus замена консенсуса потребовала бы обновления клиента и хард форк.

С фреймворком Nimbus написать механизм консенсуса так же просто, как написать 
[набор модулей Substrate](https://substrate.dev/docs/knowledgebase/runtime/pallets). Следовательно, замена консенсуса так же проста, как обновление модулей.

Тем не менее, горячая замена все еще ограничена механизмами консенсуса (фильтрами), которые укладываются в рамки Nimbus, но это может быть полезно для команд, которые еще не определились с тем, какой консенсус они хотят реализовать в долгосрочной перспективе.
