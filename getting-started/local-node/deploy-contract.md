---
title: Размещение контракта
description: Узнайте как разместить немодифицированные и неизмененные смарт-контракты на основе Solidity, на ноде Moonbeam с помощью простого скрипта с использованием Web3.js, Ethers.js или Web3.py.
---

# Использование библиотек Ethereum для размещения Smart-контрактов на Moonbeam

![Ethereum Libraries Integrations Moonbeam](/images/sendtx/web3-libraries-banner.png)

## Введение

В этом руководстве рассматривается использование компилятора Solidity и трех различных библиотек Ethereum для подписания и отправки транзакции в Moonbeam вручную. Данными библиотеками являются: 

 - [Web3.js](https://web3js.readthedocs.io/)
 - [Ethers.js](https://docs.ethers.io/)
 - [Web3.py](https://web3py.readthedocs.io/)

Кроме того, для составления смарт-контракта будут использованы еще две другие библиотеки:

 - [Solc-js](https://www.npmjs.com/package/solc) для компиляции смарт-контрактов Solidity с использованием JavaScript
 - [Py-solc-x](https://pypi.org/project/py-solc-x/) для компиляции смарт-контрактов Solidity с использованием Python

!!! note
    --8<-- 'text/common/assumes-mac-or-ubuntu-env.md'

## Проверяем необходимые требования

Тем кто использует web3.js, ethers.js необходимо предварительно установить Node.js и NPM. Для web3.py Вам понадобятся Python и PIP. На момент написания этого руководства использовались следующие версии:

 - Node.js v15.10.0
 - NPM v7.5.3
 - Python v3.6.9 (web3 requires Python >= 3.5.3 and < 4)
 - PIP3 v9.0.1

Далее, создайте папку для хранения всех соответствующих файлов: 

```
mkdir incrementer && cd incrementer/
```

Для библиотек JavaScript Вы можете сначала создать простой файл package.json (не обязательно):

```
npm init --yes
```

В каталоге установите соответствующую библиотеку и компилятор Solidity (_web3.py_ и _py-solc-x_ устанавливаются по умолчанию в каталог PIP3):

=== "Web3.js"
    ```
    npm i web3 npm i solc@0.8.0
    ```

=== "Ethers.js"
    ```
    npm i ethers npm i solc@0.8.0
    ```

=== "Web3.py"
    ```
    pip3 install web3 pip3 install py-solc-x
    ```

На момент публикации этого руководства использовались следующие версии:

 - Web3.js v1.33 (`npm ls web3`)
 - Ethers.js v5.0.31 (`npm ls ethers`)
 - Solc (JS) v0.8.0 (`npm ls solc`)
 - Web3.py v5.17.0 (`pip3 show web3`)
 - Py-solc-x v1.1.0 (`pip3 show py-solc-x`)

Настройка для этого примера будет простой и будет содержать следующие файлы:

 - **_Incrementer.sol_** — файл с нашим кодом Solidity
 - **_compile.\*_** — компилирует контракт с компилятором Solidity
 - **_deploy.\*_**: — будет обрабатывать размещения на нашей локальном ноде Moonbeam
 - **_get.\*_** — сделает вызов к ноде для получения текущего значения числа
 - **_increment.\*_** — совершает транзакцию для увеличения числа, хранящегося в ноде Moonbeam
 - **_reset.\*_** — функция, которая сбросит сохраненное число

## Файл контракта

Используемый контракт представляет собой простой инкрементатор, произвольно названный _Incrementer.sol_, который Вы можете найти [здесь](/snippets/code/web3-contract-local/Incrementer.sol). Код Solidity будет выглядеть следующим образом:

```solidity
--8<-- 'code/web3-contract-local/Incrementer.sol'
```

Функция `constructor` которая запускается при размещении контракта, устанавливает начальное значение числовой переменной, хранящейся в цепочке (по умолчанию 0). Функция `increment` добавляет предоставленное значение `_value` к текущему числу, для этого необходимо отправить транзакцию, которая изменяет сохраненные данные. Наконец, функция `reset` возвращает сохраненное значение к нулю.

!!! note
    Этот контракт представляет собой только пример и не обрабатывает значения, оборачивающиеся вокруг.


## Компиляция смарт-контракта

Единственная цель файла компиляции - использовать компилятор Solidity для вывода байт-кода и интерфейса (ABI) нашего контракта. Вы можете найти фрагменты кода для каждой библиотеки здесь (они были произвольно названы `compile.*`):

 - Web3.js: [_compile.js_](/snippets/code/web3-contract-local/compile.js)
 - Ethers.js: [_compile.js_](/snippets/code/web3-contract-local/compile.js)
 - Web3.py: [_compile.py_](/snippets/code/web3py-contract/compile.py)

!!! note
    Файл компиляции для обеих библиотек JavaScript такой же, поскольку они используют привязки JavaScript для компилятора Solidity (один и тот же пакет)

=== "Web3.js"
    ```
    --8<-- 'code/web3-contract-local/compile.js'
    ```

=== "Ethers.js"
    ```
    --8<-- 'code/web3-contract-local/compile.js'
    ```

=== "Web3.py"
    ```
    --8<-- 'code/web3py-contract/compile.py'
    ```

### Web3.js и Ethers.js

В первой части [скрипта](/snippets/code/web3-contract-local/compile.js) выбирается путь к контракту и читается его содержимое.

Затем создается входной объект компилятора Solidity, который передается в качестве входных данных функции `solc.compile`.

Наконец, извлеките данные контракта `Incrementer` из файла `Incrementer.sol`, затем экспортируйте их, чтобы сценарий размещения мог их использовать.

### Web3.py

В первой части [скрипта](/snippets/code/web3py-contract/compile.py), файл контракта компилируется с помощью функции `solcx.compile_files`. Обратите внимание, что файл контракта находится в том же каталоге, что и сценарий компиляции.

!!! note
    При запуске `compile.py` Вы можете получить сообщение об ошибке, в котором говорится, что необходимо установить `Solc`. В таком случае, раскомментируйте строку в файле, которая выполняет `solcx.install_solc()` и повторно запустите файл компиляции с помощью `python3 compile.py`. Более подробную информацию можно найти по этой [ссылке](https://pypi.org/project/py-solc-x/).

Затем, после завершения скрипта данные контракта экспортируются. В этом примере были определены только интерфейс (ABI) и байт-код.

## Размещение смарт-контракта

Независимо от библиотеки, стратегия размещения скомпилированного смарт-контракта имеет схододство. Экземпляр контракта создается с использованием его интерфейса (ABI) и байт-кода. В этом экземпляре, функция размещения используется для отправки подписанной транзакции, которая размещает контракт. Здесь Вы можете найти фрагменты кода для каждой библиотеки (они были произвольно названы `deploy.*`):

 - Web3.js: [_deploy.js_](/snippets/code/web3-contract-local/deploy.js)
 - Ethers.js: [_deploy.js_](/snippets/code/ethers-contract-local/deploy.js)
 - Web3.py: [_deploy.py_](/snippets/code/web3py-contract/deploy.py)

Файл размещения состоит из двух разделов. В первом разделе ("Define Provider & Variables") импортируется используемая библиотека, а также ABI и байт-код контракта. Также определяются провайдер и учетная запись (с закрытым ключом). Обратите внимание, что `providerRPC` имеет как стандартную конечную точку RPC автономной ноды, так и конечную точку для [Moonbase Alpha](/networks/testnet/).

Во втором разделе ("Deploy Contract") описывается фактическая часть размещения контракта. Обратите внимание, что для этого примера начальное значение числовой переменной было установлено на 5. Некоторые из ключевых выводов будут рассмотрены далее.

=== "Web3.js"
    ```
    --8<-- 'code/web3-contract-local/deploy.js'
    ```

=== "Ethers.js"
    ```
    --8<-- 'code/ethers-contract-local/deploy.js'
    ```

=== "Web3.py"
    ```
    --8<-- 'code/web3py-contract/deploy.py'
    ```

!!! note
    Скрипт _deploy.\*_ предоставляет адрес контракта в качестве вывода. Это очень удобно, поскольку он используется для взаимодействия с контрактом.


### Web3.js

В первой части [скрипта](/snippets/code/web3-contract-local/deploy.js), `web3` создается с помощью конструктора `Web3` с провайдером RPC. Изменяя RPC Вы можете выбрать, в какую сеть Вы хотите отправить транзакцию.

Закрытый ключ и связанный с ним общедоступный адрес определяются для подписания транзакции и ведения журнала. Требуется только закрытый ключ. Кроме того, байт-код и интерфейс контракта (ABI) извлекаются из экспорта компиляции.

Во второй части создается экземпляр контракта, путем предоставления ABI. Затем используется функция `deploy`, которой требуются байт-код и аргументы функции-конструктора. Это сгенерирует объект транзакции конструктора.

После этого транзакцию можно подписать с помощью метода `web3.eth.accounts.signTransaction()`. Данные поля соответствуют байт-коду, а входные аргументы конструктора кодируются вместе. Обратите внимание, что значение газа получается с использованием опции `estimateGas()` внутри транзакции конструктора.

Наконец, отправляется подписанная транзакция, адрес контракта отображается в терминале.

### Ethers.js

В первой части [скрипта](/snippets/code/ethers-contract-local/deploy.js), можно указать разные сети с помощью имени, URL-адреса RPC (обязательно) и идентификатора цепочки. Провайдер (аналогичный экземпляру `web3`) создается с помощью метода `ethers.providers.StaticJsonRpcProvider`. Альтернативой является использование метода `ethers.providers.JsonRpcProvide(providerRPC)`, который требует только адрес конечной точки RPC поставщика. Но это может создать проблемы совместимости с индивидуальными спецификациями проекта.

Закрытый ключ определяется для создания экземпляра кошелька, для которого также требуется провайдер из предыдущего шага. Экземпляр кошелька используется для подписи транзакций. Кроме того, байт-код и интерфейс контракта (ABI) извлекаются из экспорта компиляции.

Во второй части создается экземпляр контракта с помощью `ethers.ContractFactory()`, предоставляющий ABI, байт-код и кошелек. Таким образом, у экземпляра контракта уже есть подписывающая сторона. Затем используется функция `deploy`, которой требуются входные аргументы конструктора. Это отправит транзакцию для размещения контракта. Чтобы дождаться получения транзакции, Вы можете использовать метод `deployed()` транзакции размещения контракта.

Наконец, адрес контрактав отображается в терминале.

### Web3.py

В первой части [скрипта](/snippets/code/web3py-contract/deploy.py), экземпляр `web3` (или провайдер) создается с помощью метода `Web3(Web3.HTTPProvider(provider_rpc))` с RPC провайдера. Изменяя RPC провайдера, Вы можете выбрать, в какую сеть Вы хотите отправить транзакцию.

Закрытый ключ и связанный с ним общедоступный адрес определяются для подписания транзакции и установления адреса отправителя.

Во втором разделе экземпляр контракта создается с помощью `web3.eth.contract()`, предоставляя ABI и байт-код, импортированные из файла компиляции. Затем транзакцию конструктора можно построить с помощью метода `constructor().buildTransaction()`. Обратите внимание, что внутри `constructor()` Вам необходимо указать входные аргументы конструктора. Также необходимо указать исходную (`from`) учетную запись. Обязательно используйте тот, который связан с закрытым ключом. Также количество транзакций можно получить с помощью метода `web3.eth.getTransactionCount(address)`.

Транзакцию конструктора можно подписать с помощью `web3.eth.account.signTransaction()`, передав транзакцию и закрытый ключ.

Наконец, подписанная транзакция отправляется, а адрес контракта отображается в терминале.

## Чтение из смарт-контракта (методы вызова)

Методы вызова - это тип взаимодействия, который не изменяет хранилище контракта (изменяет переменные), то есть транзакцию отправлять не нужно.

Давайте рассмотрим файл _get.\*_ (самый простой из них), который извлекает текущее значение, хранящееся в контракте. Вы можете найти фрагменты кода для каждой библиотеки здесь (они были произвольно названы `get.*`):

 - Web3.js: [_get.js_](/snippets/code/web3-contract-local/get.js)
 - Ethers.js: [_get.js_](/snippets/code/ethers-contract-local/get.js)
 - Web3.py: [_get.py_](/snippets/code/web3py-contract/get.py)

Для простоты, файл get состоит из двух разделов. В первом разделе ("Define Provider & Variables") импортируются используемая библиотека и ABI контракта. Также определяется провайдер и адрес контракта. Обратите внимание, что `providerRPC` имеет как стандартную конечную точку RPC автономной ноды, так и конечную точку для [Moonbase Alpha](/networks/testnet/).

Во втором разделе ("Call Function") описывается фактический вызов контракта. Независимо от библиотеки создается экземпляр контракта (связанный с адресом контракта), из которого запрашивается метод вызова. Некоторые из основных выводов обсуждаются далее.

=== "Web3.js"
    ```
    --8<-- 'code/web3-contract-local/get.js'
    ```

=== "Ethers.js"
    ```
    --8<-- 'code/ethers-contract-local/get.js'
    ```

=== "Web3.py"
    ```
    --8<-- 'code/web3py-contract/get.py'
    ```

### Web3.js

В первой части [скрипта](/snippets/code/web3-contract-local/get.js), экземпляр `web3` (провайдер) создается с помощью конструктора `Web3` с провайдером RPC. Изменяя RPC Вы можете выбрать, в какую сеть Вы хотите отправить транзакцию.

Интерфейс контракта (ABI) и адрес также необходимы для взаимодействия с ним.

In the second section, a contract instance is created with `web3.eth.Contract()` by providing the ABI and address. Затем вызываемый метод может быть запрошен с помощью функции `contract.methods.methodName(_input).call()`, заменив `contract`, `methodName` и `_input` экземпляром контракта, функцией вызова и вводом функции (при необходимости). Функция вернет запрошенное значение.

Наконец, значение отображается в терминале.

### Ethers.js

В первой части [скрипта](/snippets/code/ethers-contract-local/get.js), можно указать разные сети с помощью имени, URL-адреса RPC (обязательно) и идентификатора цепочки. Провайдер (аналогичный экземпляру `web3`) создается с помощью метода `ethers.providers.StaticJsonRpcProvider`. Альтернативой является использование метода `ethers.providers.JsonRpcProvide(providerRPC)`, который требует только адрес конечной точки RPC провайдера. Но это может создать проблемы совместимости с индивидуальными спецификациями проекта.

Интерфейс контракта (ABI) и адрес также необходимы для взаимодействия с ним.

Во второй части экземпляр контракта создается с помощью `ethers.Contract()`, предоставляющий ABI, байт-код и кошелек. Затем, метод вызова можно запросить с помощью функции `contract.methodName(_input)`, заменив `contract`, `methodName` и `_input` экземпляром контракта, функцией вызова и вводом функции (при необходимости). Функция вернет запрошенное значение.

Наконец, значение отображается в терминале.

### Web3.py

В первой части [скрипта](/snippets/code/web3py-contract/get.py), экземпляр `web3` (провайдер) создается с помощью метода `Web3(Web3.HTTPProvider(provider_rpc))` с провайдером RPC. Изменяя RPC Вы можете выбрать, в какую сеть Вы хотите отправить транзакцию.

Интерфейс контракта (ABI) и адрес также необходимы для взаимодействия с ним.

Во второй части экземпляр контракта создается с помощью `web3.eth.contract()`, путем предоставления адреса и ABI. Затем, метод вызова можно запросить с помощью функции `contract.functions.method_name(input).call()`, заменив `contract`, `methodName` и `_input` экземпляром контракта, функцией вызова и вводом функции (при необходимости). Функция вернет запрошенное значение.

Наконец, значение отображается в терминале.

## Взаимодействие со смарт-контрактом (методы отправки)

Методы отправки - это тип взаимодействия, который изменяет хранилище контракта (изменяет переменные), то есть транзакцию необходимо подписать и отправить.

Во-первых, давайте рассмотрим файл _increment.\*_, который увеличивает текущее число, хранящееся в контракте, на заданное значение. Здесь вы можете найти фрагменты кода для каждой библиотеки (они были произвольно названы `increment.*`):

 - Web3.js: [_increment.js_](/snippets/code/web3-contract-local/increment.js)
 - Ethers.js: [_increment.js_](/snippets/code/ethers-contract-local/increment.js)
 - Web3.py: [_increment.py_](/snippets/code/web3py-contract/increment.py)

Для простоты, файл get состоит из двух разделов. В первом разделе ("Define Provider & Variables") импортируются используемая библиотека и ABI контракта. Также определяется провайдер, адрес контракта и значение функции `increment`. Обратите внимание, что `providerRPC` имеет как стандартную конечную точку RPC автономной ноды, так и конечную точку для [Moonbase Alpha](/networks/testnet/).

Во втором разделе ("Send Function") описывается фактическая функция, которая должна быть вызвана с транзакцией. Независимо от библиотеки создается экземпляр контракта (связанный с адресом контракта), из которого запрашивается функция, которая будет использоваться.

=== "Web3.js"
    ```
    --8<-- 'code/web3-contract-local/increment.js'
    ```

=== "Ethers.js"
    ```
    --8<-- 'code/ethers-contract-local/increment.js'
    ```

=== "Web3.py"
    ```
    --8<-- 'code/web3py-contract/increment.py'
    ```

Второй файл для взаимодействия с контрактом - это файл _reset.\*_, который сбрасывает число, хранящееся в контракте, на ноль. Вы можете найти фрагменты кода для каждой библиотеки здесь (они были произвольно названы `reset.*`):

 - Web3.js: [_reset.js_](/snippets/code/web3-contract-local/reset.js)
 - Ethers.js: [_reset.js_](/snippets/code/ethers-contract-local/reset.js)
 - Web3.py: [_reset.py_](/snippets/code/web3py-contract/reset.py)

Структура каждого файла очень похожа на его аналог _increment.\*_ для каждой библиотеки. Основное отличие - это вызываемый метод.

=== "Web3.js"
    ```
    --8<-- 'code/web3-contract-local/reset.js'
    ```

=== "Ethers.js"
    ```
    --8<-- 'code/ethers-contract-local/reset.js'
    ```

=== "Web3.py"
    ```
    --8<-- 'code/web3py-contract/reset.py'
    ```

### Web3.js

В первой части скрипта ([increment](/snippets/code/web3-contract-local/increment.js) или [reset](/snippets/code/web3-contract-local/reset.js) экземпляр web3 (провайдер) создается с помощью конструктора Web3 с поставщиком RPC. Изменяя RPC поставщика, предоставленный конструктору, Вы можете выбрать, в какую сеть Вы хотите отправить транзакцию.

Закрытый ключ и связанный с ним общедоступный адрес определяются для подписания транзакции и ведения журнала. Требуется только закрытый ключ. Кроме того, для взаимодействия с ним необходимы интерфейс контракта (ABI) и адрес. При необходимости Вы можете определить любую переменную, необходимую в качестве входных данных для функции, с которой Вы собираетесь взаимодействовать.

Во втором части экземпляр контракта создается с помощью `web3.eth.Contract()`, путем предоставления адреса и ABI. Затем Вы можете создать объект транзакции с помощью функции `contract.methods.methodName(_input)`, заменив `contract`, `methodName` и `_input` экземпляром контракта, функцией для вызова и вводом функции (при необходимости).

После этого транзакцию можно подписать с помощью метода `web3.eth.accounts.signTransaction()`. Поле данных соответствует объекту транзакции из предыдущего шага. Обратите внимание на то, что стоимость газа получается с помощью опции `estimateGas()` внутри объекта транзакции.

Наконец, подписанная транзакция отправляется и хеш транзакции отображается в терминале.

### Ethers.js

В первой части скрипта ([increment](/snippets/code/ethers-contract-local/increment.js) или [reset](/snippets/code/ethers-contract-local/reset.js) можно указать разные сети с помощью имени, URL-адреса RPC (обязательно) и идентификатора цепочки. Провайдер (аналогичный экземпляру web3) создается с помощью метода `ethers.providers.StaticJsonRpcProvider`. Альтернативой является использование метода `ethers.providers.JsonRpcProvide(providerRPC)`, для которого требуется только адрес конечной точки RPC провайдера. Но это может создать проблемы совместимости с индивидуальными спецификациями проекта.

Закрытый ключ определяется для создания экземпляра кошелька, для которого также требуется провайдер из предыдущего шага. Экземпляр кошелька используется для подписи транзакций. Кроме того, для взаимодействия с ним необходимы интерфейс контракта (ABI) и адрес. При необходимости Вы можете определить любую переменную, необходимую в качестве входных данных для функции, с которой Вы собираетесь взаимодействовать.

Во второй части создается экземпляр контракта с помощью `ethers.Contract()`, с указанием его адреса, ABI и кошелька. Таким образом, у экземпляра контракта уже есть подписывающая сторона. Затем транзакция, соответствующая конкретной функции, может быть отправлена с помощью функции `contract.methodName(_input)`, для этого замените `contract`, `methodName` и `_input` экземпляром контракта, функцией для вызова и вводом функции (при необходимости). Чтобы дождаться получения транзакции, Вы можете использовать метод `wait()` транзакции размещения контракта.

Наконец, в терминале отображается хеш транзакции.

### Web3.py

В первой части скрипта ([increment](/snippets/code/web3py-contract/increment.py) или [reset](/snippets/code/web3py-contract/reset.py), экземпляр `web3` (или провайдер) создается с использованием метода `Web3(Web3.HTTPProvider(provider_rpc))`с RPC провайдера. Изменяя RPC провайдера, Вы можете выбрать, в какую сеть Вы хотите отправить транзакцию.

Закрытый ключ и связанный с ним общедоступный адрес определяются для подписания транзакции и ведения журнала. Требуется только закрытый ключ. Кроме того, для взаимодействия с ним необходимы интерфейс контракта (ABI) и адрес. 

Во второй части создается экземпляр контракта с помощью `web3.eth.contract()`, путем предоставления его адреса и ABI. Затем Вы можете создать объект транзакции с помощью функции `contract.functions.methodName(_input).buildTransaction`, заменив `contract`, `methodName` и `_input` экземпляром контракта, функцией для вызова и вводом функции (при необходимости). Внутри `buildTransaction()`, необходимо указать исходную учетную запись (`from`). Обязательно используйте ту, которая связана с закрытым ключом. Также количество транзакций можно получить с помощью метода `web3.eth.getTransactionCount(address)`. 

Транзакцию можно подписать с помощью `web3.eth.account.signTransaction()`, передав объект транзакции предыдущего шага и закрытый ключ.

Наконец, в терминале отображается хеш транзакции.

## Запуск скриптов

В этом разделе показанный ранее код был адаптирован для работы с автономной нодой, которую Вы можете запустить, следуя этому [руководству](/getting-started/local-node/setting-up-a-node/). Кроме того, каждая транзакция была отправлена с предварительно пополненной учетной записи, которая поставляется с нодой:

--8<-- 'text/metamask-local/dev-account.md'

Сначала разместите контракт, запустив (обратите внимание, что каталог был переименован для каждой библиотеки):

=== "Web3.js"
    ```
    node deploy.js
    ```

=== "Ethers.js"
    ```
    node deploy.js
    ```

=== "Web3.py"
    ```
    python3 deploy.py
    ```

Это разместит контракт и вернет адрес:

=== "Web3.js"
    ![Разместить контракт Web3js](/images/deploycontract/contract-deploy-web3js.png)

=== "Ethers.js"
    ![Разместить контракт Etherjs](/images/deploycontract/contract-deploy-ethers.png)

=== "Web3.py"
    ![Разместить контракт Web3py](/images/deploycontract/contract-deploy-web3py.png)

Затем запустите _increment.\*_ файл. Вы можете использовать файл get для проверки значения числа, хранящегося в контракте, до и после его увеличения:


=== "Web3.js"
    ```
    # Get value
    node get.js 
    # Increment value
    increment.js
    # Get value
    node get.js
    ```

=== "Ethers.js"
    ```
    # Get value
    node get.js 
    # Increment value
    increment.js
    # Get value
    node get.js
    ```

=== "Web3.py"
    ```
    # Get value
    python3 get.py 
    # Increment value
    python3 increment.py
    # Get value
    python3 get.py
    ```

Это отобразит значение до транзакции increment, хэш транзакции и значение после:

=== "Web3.js"
    ![Увеличить контракт Web3js](/images/deploycontract/contract-increment-web3js.png)

=== "Ethers.js"
    ![Увеличить контракт Etherjs](/images/deploycontract/contract-increment-ethers.png)

=== "Web3.py"
    ![Увеличить контракт Web3py](/images/deploycontract/contract-increment-web3py.png)

Наконец, запустите файл сброса. Еще раз, Вы можете использовать файл get для проверки значения числа, хранящегося в контракте, до и после его сброса:

=== "Web3.js"
    ```
    # Get value
    node get.js 
    # Reset value
    node reset.js 
    # Get value
    node get.js
    ```

=== "Ethers.js"
    ```
    # Get value
    node get.js 
    # Reset value
    node reset.js 
    # Get value
    node get.js
    ```

=== "Web3.py"
    ```
    # Get value
    python3 get.py 
    # Reset value
    python3 reset.py
    # Get value
    python3 get.py
    ```

Это отобразит значение до сброса, хэш транзакции и значение после:

=== "Web3.js"
    ![Сбросить Contract Web3js](/images/deploycontract/contract-reset-web3js.png)

=== "Ethers.js"
    ![Сбросить Contract Etherjs](/images/deploycontract/contract-reset-ethers.png)

=== "Web3.py"
    ![Сбросить Contract Web3py](/images/deploycontract/contract-reset-web3py.png)

