---
title: Отправка транзакции
description: Узнайте, как создавать и отправлять транзакции в сети Moonbeam, совместимой с Ethereum, с помощью простого скрипта с использованием web3.js, ethers.js или web3.py.
---

# Использование библиотек Ethereum для отправки транзакций в сети Moonbeam

![Ethereum Libraries Integrations Moonbeam](/images/sendtx/web3-libraries-banner.png)

## Введение

В этом руководстве рассматривается использование трех разных библиотек Ethereum для ручной подписи и отправки транзакции на Moonbeam. В этом руководстве рассматривается работа трёх библиотек:

 - [Web3.js](https://web3js.readthedocs.io/)
 - [Ethers.js](https://docs.ethers.io/)
 - [Web3.py](https://web3py.readthedocs.io/)

!!! Примечание
    --8<-- 'text/common/assumes-mac-or-ubuntu-env.md'

## Проверка предварительных условий

Примеры, использующие как web3.js, так и ethers.js, требуют предварительной установки Node.js и NPM. В примере с использованием web3.py требуются Python и PIP. На момент написания этого руководства использовались следующие версии:

 - Node.js v15.10.0
 - NPM v7.5.3
 - Python v3.6.9 (web3 требуется Python >= 3.5.3 and < 4)
 - PIP3 v9.0.1

Затем создайте каталог для хранения всех соответствующих файлов:

```
mkdir transaction && cd transaction/
```

Для библиотек JavaScript Вы можете сначала создать простой файл package.json (не обязательно):

```
npm init --yes
```

В каталоге установите используемую библиотеку (web3.py устанавливается в каталог PIP3 по умолчанию):

=== "Web3.js"
    ```
    npm i web3
    ```

=== "Ethers.js"
    ```
    npm i ethers
    ```

=== "Web3.py"
    ```
    pip3 install web3
    ```

На момент публикации этого руководства использовались следующие версии:

 - Web3.js v1.33 (`npm ls web3`)
 - Ethers.js v5.0.31 (`npm ls ethers`)
 - Web3.py v5.17.0 (`pip3 show web3`)

## Файл транзакции

Для выполнения транзакции между учетными записями нужен только один файл. Сценарий, показанный в этом разделе, перенесет 1 токен с исходного адреса (на котором Вы храните закрытый ключ) на другой адрес. Вы можете найти фрагменты кода для каждой библиотеки здесь (они были произвольно названы `transaction. *`):

 - Web3.js: [_transaction.js_](/snippets/code/web3-tx-local/transaction.js)
 - Ethers.js: [_transaction.js_](/snippets/code/ethers-tx-local/transaction.js)
 - Web3.py: [_transaction.py_](/snippets/code/web3py-tx/transaction.py)

Каждый из файлов, независимо от используемой библиотеки, разделен на три раздела. В первом разделе ("Определение поставщика и переменных") импортируется используемая библиотека, а также определяются поставщик и другие переменные (переменные зависят от библиотеки). Обратите внимание, что `providerRPC` имеет как стандартную конечную точку RPC для автономного узла, так и конечную точку для [Moonbase Alpha](/networks/testnet/).

Во втором разделе ("Создание и транзакция транзакции") функции, необходимые для отправки самой транзакции. Некоторые из основных выводов обсуждаются далее.

=== "Web3.js"
    ```
    --8<-- 'code/web3-tx-local/transaction.js'
    ```

=== "Ethers.js"
    ```
    --8<-- 'code/ethers-tx-local/transaction.js'
    ```

=== "Web3.py"
    ```
    --8<-- 'code/web3py-tx/transaction.py'
    ```

### Web3.js

В первом разделе [скрипт](/snippets/code/web3-tx-local/transaction.js), `web3` создается с помощью конструктора `Web3` с поставщиком RPC. Изменяя RPC поставщика, предоставленный конструктору, Вы можете выбрать, в какую сеть Вы хотите отправить транзакцию.

Закрытый ключ и связанный с ним общедоступный адрес определяются для подписания транзакции и ведения журнала соответственно. Требуется только закрытый ключ.

`addressTo`, куда будет отправлена транзакция, также определяется здесь, и он является обязательным.

Во втором разделе создается объект транзакции с полями `to`, `value` и `gas`. Они описывают получателя, сумму для отправки и газ, потребленный транзакцией (в данном случае 21000).Вы можете использовать функцию `web3.utils.toWei()` для ввода значения в ETH (например) и получения вывода в WEI. Транзакция подписывается закрытым ключом с помощью метода `web3.eth.accounts.signTransaction ()`. Обратите внимание, что это возвращает обещание, которое необходимо разрешить.

Затем, подписав транзакцию (Вы можете вопспользоваться `console.log (createTransaction)`, чтобы увидеть значения v-r-s), можно отправить ее с помощью метода `web3.eth.sendSignedTransaction ()`, предоставив подписанную транзакцию, расположенную в `createTransaction.rawTransaction`.

Наконец, запустите функцию асинхронного размещения.

### Ethers.js

В первом разделе [the script](/snippets/code/ethers-tx-local/transaction.js), можно указать разные сети с помощью имени, URL-адреса RPC (обязательно) и идентификатора цепочки. Провайдер (аналогичный экземпляру `web3`) создается с помощью метода `ethers.providers.StaticJsonRpcProvider`. Альтернативой является использование метода `ethers.providers.JsonRpcProvide (providerRPC)`, для которого требуется только адрес конечной точки RPC поставщика. Но это могло создать проблемы совместимости с индивидуальными спецификациями проекта.

Закрытый ключ определяется для создания экземпляра кошелька, для которого также требуется поставщик из предыдущего шага. Экземпляр кошелька используется для подписи транзакций.

`addressTo`, куда будет отправлена транзакция, также определяется здесь, и он является обязательным.

Во втором разделе асинхронная функция обертывает метод `wallet.sendTransaction(txObject)`. Объект транзакции довольно простой. Требуется только адрес получателя и сумма для отправки. Обратите внимание, что можно использовать `ethers.utils.parseEther()`, который обрабатывает необходимые преобразования единиц из ETH в WEI - аналогично использованию `ethers.utils.parseUnits (value, 'ether')`.

После отправки транзакции Вы можете получить ответ транзакции (в этом примере с именем`createReceipt`), который имеет несколько свойств. Например, Вы можете вызвать метод `createReceipt.wait ()`, чтобы дождаться обработки транзакции (статус получения - ОК).

Наконец, запустите функцию асинхронного развертывания.

### Web3.py

В первом разделе [скрипта](/snippets/code/web3py-tx/transaction.py), экземпляр `web3` (или поставщик) создается с помощью метода `Web3(Web3.HTTPProvider (provider_rpc))` и указанием RPC поставщика. Изменяя RPC поставщика, Вы можете выбрать, в какую сеть Вы хотите отправить транзакцию.

Закрытый ключ и связанный с ним общедоступный адрес определяются для подписания транзакции и ведения журнала. Публичный адрес не требуется.

`addressTo`, куда будет отправлена транзакция, также определяется здесь, и он является обязательным.

Во втором разделе объект транзакции создается с полями `nonce`, `gasPrice`, `gas`, `to`, и `value`.  Они описывают количество транзакций, цену на газ (0 для автономной версии и Moonbase Alpha), газ (в данном случае 21000), получателя и сумму для отправки. Обратите внимание, что количество транзакций можно получить с помощью метода `web3.eth.getTransactionCount(address)`. Кроме того, Вы можете использовать функцию `web3.toWei()` для ввода значения в ETH (например) и получения вывода в WEI. Транзакция подписывается закрытым ключом с помощью метода `web3.eth.account.signTransaction ()`.

Затем, подписав транзакцию, Вы можете отправить ее с помощью метода `web3.eth.sendSignedTransaction()` предоставив подписанную транзакцию, расположенную в `createTransaction.rawTransaction`.

## Файл баланса

Перед запуском скрипта другой файл проверяет баланс обоих адресов до и после транзакции. Это легко сделать, просто запросив баланс счета.

Вы можете найти фрагменты кода для каждой библиотеки здесь (файлы были произвольно названы `balances.*`):

 - Web3.js: [_balances.js_](/snippets/code/web3-tx-local/balances.js)
 - Ethers.js: [_balances.js_](/snippets/code/ethers-tx-local/balances.js)
 - Web3.py: [_balances.py_](/snippets/code/web3py-tx/balances.py)

Для простоты файл баланса состоит из двух разделов. Как и раньше, в первом разделе ("Определить поставщика и переменные") импортируется используемая библиотека, а также определяются поставщик и адрес от/до (для проверки остатков).

Во втором разделе ("Функция вызова баланса") описаны функции, необходимые для получения балансов по ранее определенным счетам. Обратите внимание, что `providerRPC` имеет как стандартную конечную точку RPC автономного узла, так и конечную точку для [Moonbase Alpha](/networks/testnet/). Некоторые из основных выводов обсуждаются далее.

=== "Web3.js"
    ```
    --8<-- 'code/web3-tx-local/balances.js'
    ```

=== "Ethers.js"
    ```
    --8<-- 'code/ethers-tx-local/balances.js'
    ```

=== "Web3.py"
    ```
    --8<-- 'code/web3py-tx/balances.py'
    ```

### Web3.js

Первый раздел [скрипта](/snippets/code/web3-tx-local/balances.js) очень похож на раздел в [файле транзакции](/getting-started/local-node/send-transaction/#web3js). Основное отличие состоит в том, что закрытый ключ не требуется, потому что нет необходимости отправлять транзакцию.

Во втором разделе асинхронная функция обертывает метод web3, используемый для получения баланса адреса, `web3.eth.getBalance(address)`. Еще раз, вы можете использовать функцию `web3.utils.fromWei()`, чтобы преобразовать баланс в более читаемое число в ETH.

### Ethers.js

Первый раздел [скрипта](/snippets/code/ethers-tx-local/balances.js) очень похож на раздел в [файле транзакции](/getting-started/local-node/send-transaction/#ethersjs). Основное отличие состоит в том, что закрытый ключ не требуется, потому что нет необходимости отправлять транзакцию. Напротив, необходимо определить `addressFrom` адрес.

Во втором разделе асинхронная функция обертывает метод поставщика, используемый для получения баланса адреса, которым является `provider.getBalance(address)`. Еще раз, Вы можете использовать функцию `ethers.utils.formatEther()` чтобы преобразовать баланс в более читаемое число в ETH.

### Web3.py

Первый раздел [скрипта](/snippets/code/web3py-tx/balances.py) очень похож на раздел в [файле транзакций](/getting-started/local-node/send-transaction/#web3py). Основное отличие состоит в том, что закрытый ключ не требуется, потому что нет необходимости отправлять транзакцию.

Во втором разделе метод `web3.eth.getBalance(address)` используется для получения баланса целевого адреса. Еще раз, Вы можете использовать функцию `eb3.fromWei()`, чтобы преобразовать баланс в более читаемое число в ETH.

## Запуск скриптов

В этом разделе показанный ранее код был адаптирован для работы с автономным узлом, который Вы можете запустить, следуя [этому руководству](/getting-started/local-node/setting-up-a-node/).Кроме того, каждая транзакция была отправлена с предварительно пополненной учетной записи, которая поставляется с узлом:

--8<-- 'text/metamask-local/dev-account.md'

Сначала проверьте баланс обоих адресов перед транзакцией, запустив (обратите внимание, что каталог был переименован для каждой библиотеки):

=== "Web3.js"
    ```
    node balances.js
    ```

=== "Ethers.js"
    ```
    node balances.js
    ```

=== "Web3.py"
    ```
    python3 balances.py
    ```

Затем запустите сценарий _transaction.\*_ для выполнения транзакции:

=== "Web3.js"
    ```
    node transaction.js
    ```

=== "Ethers.js"
    ```
    node transaction.js
    ```

=== "Web3.py"
    ```
    python3 transaction.py
    ```

И на последок еще раз проверьте баланс, чтобы убедиться, что перевод прошел успешно. Все выполнение должно выглядеть так:

=== "Web3.js"
    ![Send Tx Web3js](/images/sendtx/sendtx-web3js.png)

=== "Ethers.js"
    ![Send Tx Etherjs](/images/sendtx/sendtx-ethers.png)

=== "Web3.py"
    ![Send Tx Web3py](/images/sendtx/sendtx-web3py.png)

